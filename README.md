#知识点部分
##计算机专业相关知识点
###操作系统
- **进程和线程的区别和联系**

进程是分配内存计算机资源的基本单位，线程是CPU调度和分派的基本单位，共享内存空间；进程更加健壮，但切换效率低，线程开销小，但是不利于资源管理。

一个程序至少有一个进程，一个进程至少有一个线程

- **死锁的必要条件&怎么处理死锁**

死锁产生的必要条件：互斥条件，不可抢占条件，占有且申请条件，循环等待条件
死锁的预防：打破上述四个条件
死锁的避免：安全序列，银行家算法
死锁的恢复：重新启动，撤销进程剥夺资源

 
- **进程的几种状态&状态间的转换**

![enter image description here](http://img.blog.csdn.net/20140806162319890)
创建和退出不是状态
阻塞是等待cpu以外的资源，就绪是等待cpu资源

- **Window内存管理方式：段存储，页存储，段页存储**

空闲内存管理：使用位图的存储管理，使用链表的存储管理

空闲内存的四种分配算法：首次适应法，下次匹配法，最佳适应法，最坏适应法

cpu段式管理：段式管理的基本原理是指把一个程序分成若干个段（segment）进行存储，每个段都是一个逻辑实体（logical entity）。一个用户作业或进程所包含的段对应一个二维线形虚拟空间，程序通过分段(segmentation)划分为多个模块，故可以对程序的各个模块分别编写和编译。段式管理程序以段为单位分配内存，然后通过地址影射机构把段式虚拟地址转换为虚拟地址。
cpu页式管理： 页式管理的基本原理将各进程的虚拟空间划分成若干个长度相等的页(一般为4K)，页式管理把内存空间按页的大小划分成片或者页面（page frame），然后把页式虚拟地址与内存地址建立一一对应页表，并用相应的硬件地址变换机构，来解决离散地址变换问题。
CPU将一个虚拟内存空间中的地址转换为物理地址，需要进行两步：首先将给定一个逻辑地址，CPU要利用其段式内存管理单元，先将每个逻辑地址转换成一个线程地址，再利用其页式内存管理单元，转换为最终物理地址。这就是我们所知道的段页式管理，这样两次转换的好处可以克服段式管理和页式管理的缺点。

![enter image description here](http://images.cnitblog.com/blog/215944/201307/17162141-b95876a4f5f745468b98a26431720a90.jpg)
![enter image description here](http://images.cnitblog.com/blog/215944/201307/17163751-d155e69e6a924c4fbdc8589e682ed1db.jpg)

- **进程间通信**

通信目的：数据传输，共享数据，通知事，资源共享，进程控制

管道：
>管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
流管道s_pipe: 去除了第一种限制,可以双向传输。
管道可用于具有亲缘关系进程间的通信，命名管道:name_pipe克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。

信号量：
>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列:
>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

信号:
>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。主要作为进程间以及同一进程不同线程之间的同步手段。

共享内存:
>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

套接字：
>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

- **逻辑地址、线性地址、物理地址**

逻辑地址：包含在机器语言指令中用来指定一个操作数或一条指令的地址，每个逻辑地址都由一个段和偏移量组成，表示为[段标识符：段内偏移量]。例如，在C/C++程序中我们使用指针对变量地址操作，该地址就是逻辑地址（准确的应该说是逻辑地址的段内偏移量）。对应上述段式管理，逻辑地址是段式管理转换前的程序地址。
线性地址：也称为虚拟地址，它是一个32位无符号整数，故可以用来表达高达4GB的地址。线性地址同逻辑地址一样也是不真实的地址。对应上述页式管理，线性地址是页式管理转换前的地址。
物理地址：用于内存芯片级内存单元寻址，与处理器和CPU连接的地址总线相对应。一般情况下，我们说的计算机内存条中的内存就是它。

- **换页算法**

最优页面置换算法，先进先出页面置换算法，第二次机会页面置换算法，时钟页面置换算法，最近最少使用页面置换算法

- **虚拟内存**

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。

两种处理内存超载的方法：交换技术，虚拟内存技术

###计算机网络
- **OSI与TCP/IP各层的结构与功能，都有哪些协议**

OSI： 应用层，提供为应用软件而设的界面，HTTP,HTTPS,FTP,SSH（加密安全登陆）,SMTP（收邮件）,POP3（发邮件）

表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式

会话层：负责在数据传输中设置和维护电脑网络中两台电脑之间的通信连接

传输层：把传输表头(TH)加至数据以形成数据包。传输表头包含了所使用的协议等发送信息，TCP，UDP

网络层：决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成分组。网络表头包含了网络数据，IP

数据链路层：负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成了帧。数据链表头(DLH)是包含了物理地址和错误侦测及改错的方法。数据链表尾(DLT)是一串指示数据包末端的字符串

物理层：在局部局域网上传送帧，它负责管理电脑通信设备和网络媒体之间的互通

TCP/IP：该层包括所有和应用程序协同工作，利用基础网络交换应用程序专用的数据的协议，HTTP,FTP,DNS

传输层：能够解决诸如端到端可靠性和保证数据按照正确的顺序到达这样的问题，TCP,UDP

网络互联层：解决在一个单一网络上传输数据包的问题，IP

网络接口层：它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法

DHCP（动态配置IP地址），DNS（域名服务），ARP（地址解析协议）
ARP负责把IP地址解析成MAC地址；DNS负责把域名解析成IP地址。

- **TCP与UDP的区别**

![Alt text](./QQ图片20160802170738.png)

- **TCP，IP报文结构**

![enter image description here](http://img.my.csdn.net/uploads/201109/8/0_1315497633XFTf.gif)
![enter image description here](http://img.my.csdn.net/uploads/201109/8/0_131549627162sy.gif)

- **TCP的三次握手与四次挥手过程，各个状态名称与含义，TIMEWAIT的作用**

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
![enter image description here](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png)
![enter image description here](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png)

- **TCP拥塞控制**

整体网络的流量控制，慢开始（从1开始，指数增长），拥塞避免（到达阈值，线性增长），快重传（减小超时时间），快恢复（拥塞后不是降为1而是降为阈值）

- **TCP滑动窗口与回退N针协议**

是一种端到端流量控制技术，改善吞吐量，1比特滑动窗口协议，后退n协议，选择重传协议

- **Http的报文结构**

http请求报文：请求行（请求方法，请求URL，HTTP协议及版本），请求头（报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息），请求体（将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据）

http响应报文：响应行（报文协议及版本，状态码及状态描述），响应头（有多个属性组成），响应体（真正想要的内容）

- **Http的状态码含义**

>成功的状态码：  
200 – 服务器成功返回网页  
304 – 未修改  
失败的状态码：  
404 – 请求的网页不存在  
503 – 服务器暂时不可用  
500 – 服务器内部错误  

- **Http request的几种类型**

常用的有get，post
>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。 
HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 
GET：向特定的资源发出请求。 
POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 
PUT：向指定资源位置上传其最新内容。 
DELETE：请求服务器删除Request-URI所标识的资源。 
TRACE：回显服务器收到的请求，主要用于测试或诊断。 

CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

- **Http1.1和Http1.0的区别**

在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接
在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求

- **Http怎么处理长连接**

http要建立长连接，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

- **Cookie与Session的作用和原理**

Session：服务端保存的数据结构，用来跟踪用户状态，保存在集群、数据库文件中

Cookie：客户端保存用户信息，记录用户信息

采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的

服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。cookie的内容主要包括：名字，值，过期时间，路径和域，路径与域合在一起就构成了cookie的作用范围。不设置过期时间，cookie放在内存里，随浏览器的关闭而删除；设置过期时间，则存在硬盘中，存储在硬盘上的cookie可以在不同的浏览器进程间共享。

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id。由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器，经常被使用的一种技术叫做URL重写。

- **电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP**

第一步，解析域名，找到主机IP。
>（1）浏览器会缓存DNS一段时间，一般2-30分钟不等。如果有缓存，直接返回IP，否则下一步。
（2）缓存中无法找到IP，浏览器会进行一个系统调用，查询hosts文件。如果找到，直接返回IP，否则下一步。（在计算机本地目录etc下有一个hosts文件，hosts文件中保存有域名与IP的对应解析，通常也可以修改hosts科学上网或破解软件。）
（3）进行了（1）（2）本地查询无果，只能借助于网络。路由器一般都会有自己的DNS缓存，ISP服务商DNS缓存，这时一般都能够得到相应的IP。如果还是无果，只能借助于DNS递归解析了。
（4）这时，ISP的DNS服务器就会开始从根域名服务器开始递归搜索，从.com顶级域名服务器，具体的域名服务器。

第二部，浏览器与网站建立TCP连接。
>三步握手建立连接

第三部分，浏览器发起GET请求 。
>浏览器向主机发起一个HTTP-GET方法报文请求。请求中包含访问的URL。Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。

第四部分，显示页面或返回其他。
>返回状态码200 OK，表示服务器可以相应请求，返回报文，由于在报头中Content-type为“text/html”，浏览器以HTML形式呈现，而不是下载文件。但是，对于大型网站存在多个主机站点，往往不会直接返回请求页面，而是重定向。返回的状态码就不是200 OK，而是301,302以3开头的重定向码，浏览器在获取了重定向响应后，在响应报文中Location项找到重定向地址，浏览器重新第一步访问即可。重定向是为了负载均衡或者导入流量。

- **ICMP报文是什么，Ping的整个过程。**

>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

- 首先本机发送域名请求数据到PC设置的DNS ip
- PC通过子网掩码判断DNS ip是本网段还是跨网段（这里只考虑跨网段）
- 由于是跨网段，PC发送DNS域名解析数据包到PC设置的网关ip上。（此时先要进行二层的mac转发，PC查看本机arp缓存表，如果表中有网关的mac地址，直接转发，如果没有，使用arp解析协议解析到网关的mac地址。之后封装成数据帧发送到三层网络层）此时PC发送三层数据到网关，源地址为PC内网地址，目的地址为DNS ip地址。而在二层源mac地址为PC mac地址，目的mac地址为网关mac地址。
- 路由内网网关收到数据包，根据数据包的目的地址，查看路由表。根据路由表发送数据到下一跳上。（发送前，数据到达路由外网端口，会根据nat地址转换配置。形成一条内网ip+port与外网ip+port的一一对应关系。）
- 发送到下一跳和内网通信都是一样的，查看路由arp缓存表，如果有下一跳mac地址，就直接发送，没有的话需要arp协议解析一下。
- 对端路由收到数据包，再接着根据路由表判断下一跳。这样一跳一跳地，最后到达DNS服务器。服务器将查询结果返回。
- 返回的数据包在ISP的网络里最后寻址到你的路由器上，你的路由器收到数据包后，会查询路由nat连接表，寻找ip+port关系对应的内网ip。拆分数据包，封装成帧，最后PC收到域名对应的ip地址。
【到这里，域名解析过程完成，接下来ping对方ip，过程与上面几乎一样】
- 再发起一次PC到目的域名ip地址的一次ping请求信息
- PC通过子网掩码判断对方ip是本网段还是跨网段（这里只考虑跨网段）
- 由于是跨网段，PC发送数据包到网关ip上。
- 路由内网网关收到数据包，根据数据包的目的地址，查看路由表。根据路由表发送数据到下一跳上。（发送前，数据到达路由外网端口，会根据nat地址转换配置。形成一条内网IP+port与外网ip+port的一一对应关系。）
- 发送到下一跳和内网通信都是一样的，查看路由arp缓存表，如果有下一跳mac地址，就直接发送，没有的话就是要arp协议解析一下。
- 服务器收到数据包后，会重新构建一个ICMP应答包，然后返回。
- 返回的数据包在ISP的网络里最后寻址到你的路由器上，你的路由器收到数据包后，会查询路由nat连接表，寻找ip+port关系对应的内网ip。拆分数据包，封装成帧，最后PC收到ICMP应答数据包。
整个过程到此结束。在整个这个过程中，源ip地址和目的ip地址是不变的（内网到路由器段不算在内）而mac地址是变的。

- **C/S模式下使用socket通信，几个关键函数**

>int socket(int domain, int type, int protocol);创建socket
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);把一个地址族中的特定地址赋给socket
通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。
int listen(int sockfd, int backlog);服务器监听请求
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);客户端请求连接
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。
read()、write()
close()。close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。

- **IP地址分类**

![enter image description here](http://i411.photobucket.com/albums/pp198/ylqmf/develope/0d72994498edd96c510ffe13.jpg)

D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。
E类IP地址以“1111”开始，为将来使用保留。
全零（“0．0．0．0”）地址指任意网络。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。

- **路由器与交换机区别**

路由器谋短，交换机求快。

>交换机：硬件处理交换 (转发) 过程；一次路由(寻路)，多次交换(转发)
路由器：软件处理交换 (转发) 过程；一次路由(寻路)，一次交换(转发)
工作层次不同：交换机主要工作在数据链路层（第二层）；路由器工作在网络层（第三层）。
转发依据不同：交换机转发所依据的对象时：MAC地址。（物理地址）；路由转发所依据的对象是：IP地址。（网络地址）

- **http和socket的区别和联系**

HTTP是应用层协议，主要解决如何包装数据，Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。

http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断掉；socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；但是由于各种环境因素可能会是连接断开，所以当一个socket连接中没有数据的传输，那么为了维持连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。

socket网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP）。

- **http和https的区别**
>http运行在tcp上，明文，客户端和服务器都无法验证对方身份
>https运行在ssl/tls上，ssl/tls运行在tcp之上，对成加密，客户端可以验证服务器，若配置了客户端验证，服务器也可以验证客户端


###数据结构和算法
- **字符串操作**

- **Hash表的hash函数，冲突解决方法有哪些**

hash函数：直接定址法，除法散列法，平方散列法（乘法和位移操作），斐波那契散列法（那斐波那契数作为乘数）

解决hash冲突的方法：开放定址法，再哈希法，链地址法，公共溢出区法

- **各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定**

归并排序：O（nlogn）O（n） 稳定的 最坏情况O（nlogn）

快速排序：O（nlogn）O（n） 不稳定的 最坏情况O（n2）

冒泡排序：O（n2）O（1） 稳定的 最好情况O（n）

简单选择排序：O（n2）O（1） 稳定的 

直接插入排序：O（n2）O（1） 稳定的 最好情况O（n）

堆排序：O（nlogn） O（1） 不稳定的 最坏情况O（nlogn）
（先与末尾交换，再移走末尾，再调整）

希尔排序：最好情况O（n1.3）最坏情况O（n2） 不稳定的 空间O（1）
（将相距某个增量的记录组成一个子序列，使得结果小的在前大的在后基本有序）

桶排序：鸽巢排序的归纳结果，不是比较排序，当各个桶均匀分配时为线性时间

- **快排的partition函数与归并的Merge函数**

```java

public static void quickSort(int[] arr){
    qsort(arr, 0, arr.length-1);
}
private static void qsort(int[] arr, int low, int high){
    if (low < high){
        int pivot=partition(arr, low, high);        //将数组分为两部分
        qsort(arr, low, pivot-1);                   //递归排序左子数组
        qsort(arr, pivot+1, high);                  //递归排序右子数组
    }
}
private static int partition(int[] arr, int low, int high){
    int pivot = arr[low];     //枢轴记录
    while (low<high){
        while (low<high && arr[high]>=pivot) --high;
        arr[low]=arr[high];             //交换比枢轴小的记录到左端
        while (low<high && arr[low]<=pivot) ++low;
        arr[high] = arr[low];           //交换比枢轴小的记录到右端
    }
    //扫描完成，枢轴到位
    arr[low] = pivot;
    //返回的是枢轴的位置
    return low;
}
```

``` java
    public static void merge(int[] data, int left, int center, int right) {  
        // 临时数组  
        int[] tmpArr = new int[data.length];  
        // 右数组第一个元素索引  
        int mid = center + 1;  
        // third 记录临时数组的索引  
        int third = left;  
        // 缓存左数组第一个元素的索引  
        int tmp = left;  
        while (left <= center && mid <= right) {  
            // 从两个数组中取出最小的放入临时数组  
            if (data[left] <= data[mid]) {  
                tmpArr[third++] = data[left++];  
            } else {  
                tmpArr[third++] = data[mid++];  
            }  
        }  
        // 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）  
        while (mid <= right) {  
            tmpArr[third++] = data[mid++];  
        }  
        while (left <= center) {  
            tmpArr[third++] = data[left++];  
        }  
        // 将临时数组中的内容拷贝回原数组中  
        // （原left-right范围的内容被复制回原数组）  
        while (tmp <= right) {  
            data[tmp] = tmpArr[tmp++];  
        }  
    } 
```



- **对冒泡与快排的改进**

冒泡排序优化：在一遍没有操作时，直接结束排序
快速排序优化：优化选取枢轴；优化不必要的交换（取出来，不交换，直接放到最终位置上）；优化小数组时排序方案；优化递归操作

- **查找，与变种二分查找**

二分查找优化：插值查找（是在所期望的地址附近开始查找   (key-a[low])/(a[high]-a[low])）
索引查找：稠密索引；分块索引（块间有序，块内无序）；倒排索引（不是由记录确定属性值，而是由属性值确定记录）

- **B树、B+树、AVL树、红黑树、哈夫曼树**

B树：叶子都在同一层，不包含任何信息；最多有m个节点，至少有m/2个节点；若某个节点有n个节点，则有n+1个子树，叶子节点不包含任何关键字信息
B+树：用于文件系统，叶子节点包含全部关键字信息，还有下个节点的指针，叶子节点相连接；分值节点变成索引，只包含树的最大最小关键字，磁盘读写代价更低，查询效率更加稳定

- **二叉树的前中后续遍历：递归与非递归写法，层序遍历算法**

- **图的BFS与DFS算法**

- **最小生成树算法**

Prim算法：每次选一个代价最小的顶点加入（适合稠密图）
Kruskal算法：每次选一条最短的边加入（适合稀疏图）

- **最短路径算法**

Dijkstra算法：用于求某个顶点到其余各个顶点的最短路径，复杂度O（n2）
>a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。
b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。
c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。
d.重复步骤b和c直到所有顶点都包含在S中。

Floyd算法：用于求所有定点到其他所有顶点的最短路径，复杂度O（n3）；假设k=1，2，3...n为中间转折点
>a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　
b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html

- **KMP算法**

- **排列组合问题**

- **动态规划、贪心算法、分治算法**

动态规划：最优子结构，重叠子问题，自底向上，空间需求大，有状态转移方程
贪心算法：最优子结构，只有一个子问题，自顶向下，并不一定最优
例：三角形数塔问题

- **大数据处理：10亿条数据找出最大的1000个数**

堆排序；hash到桶中，最大的那个桶；分治法，分段排序，再综合处理

- **胜者树和败者树**
>属于树形选择排序
>胜者数：如果一个选手的值改变了，可以很容易的修改这棵胜者树
>败者树：用父节点记录左右节点的败者，而让胜者参加下一轮比赛，败者树简化了重构，使重构只与该节点的父节点记录有关，而胜者树的重构还与该节点的兄弟节点有关


##后台研发相关知识点
###JVM
- **JVM调优**
>新对象预留在年轻代，分配合理年轻代空间
>大对象进入老年代，小对象进入老年代会成为灾难
>设置对象进入老年代年龄
>稳定的java堆（GC次数少，时间长）VS动荡的java堆（GC时间短）
>增大吞吐量，使用并行回收收集器
>使用非占有的垃圾回收器降低停顿
>使用大的内存分页，提升寻址能力

- **内存模型以及分区，需要详细到每个区放什么**

线程共享数据：堆（存放所有对象实例），方法区（用于存储JVM加载的类信息、常量、静态变量、即使编译器编译后的代码等数据），运行常量池（是方法区的一部分，用于存放编译器生成的各种字面量和符号引用）

线程隔离区：程序计数器（一小块内存空间，单前线程所执行的字节码行号指示器），本地方法栈（为JVM用到的Native方法服务），虚拟机栈（Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息）

- **堆里面的分区：Eden，survival from to，老年代，各自的特点**

堆内存分为两大部分：新生代和老年代。比例为1：2。
老年代主要存放应用程序中生命周期长的存活对象。
新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。
Eden区存放新生的对象。
Survivor存放每次垃圾回收后存活的对象。

- **对象创建方法，对象的内存分配，对象的访问定位**

对象的创建：
当虚拟机遇到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且坚持这个符号引用对应的类是否已经加载，解析，初始化如果没有的话，必须先执行相应类的加载。
类加载检查之后，虚拟机就要为新生的对象分配内存，为对象分配内存空间相当于在java堆中开辟一块和新生对象一样大小的内存。
内存分配之后，虚拟机将分配到内存的空间初始化，这一操作为了保证对象的实例字段在未被赋初始值就可以使用。接下来就要对对象就行必要的设置，去执行init()方法。

对象的内存布局：
对象头中包括两部分信息，一部分用于存储对象自身的运行时数据，如哈希码，锁状态标志等；另一部分时类型指针，即对象指向它的类元数据的指针，虚拟机就是通过此指针来确定这个对象属于哪个类的实例。
实例数据时对象真正存储的有效信息，也是在程序中定义的各个字段的内容，至于这部分的存储顺序是由虚拟机的分配策略和在Java中中定义的顺序决定的，其中父类中定义的变量一定会出现在子类定义的变量之前。
对象对齐填充，其实它并不一定存在，在Hot Spot在虚拟机的内存管理系统要求对象起始位置的大小必须是8字节的整数倍，所以当对象实例数据部分没有对齐，就需要对齐补充来补全。

对象的访问定位：
如果使用句柄访问，Java堆中首先划分出一块内存作为句柄池，reference中存储的是句柄的地址，而句柄中存储的是对象实例数据和类型数据的地址信息。
如果使用直接指针访问，reference中存储的就是对象的地址，而Java堆对象的布局中就必须考虑如何放置访问堆对象的信息。

- **GC的两种判定方法：引用计数与引用链**

引用计数法：实现简单，效率高，无法解决相互循环引用问题

可达性分析算法：通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的


- **GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路**

标记清除：效率不高，会产生空间碎片

增量回收：把堆分为多个区域，每次回收多个区域

复制算法：实现简单高效，内存变为原来一半，一般用来回收新生代，一块Eden和两块Survivor，比例大概8：1，如果Survivor空间不够用则让老年代进行分配担保

标记整理算法：一般用于老年代

分代收集算法

- **GC收集器有哪些？CMS收集器与G1收集器的特点**

并行：垃圾回收线程之间，互相间无共享状态，停顿时间短，效率高
并发：垃圾回收与用户进程间，有状态，大大缩短停顿时间，会产生浮动垃圾和碎片，空间未满就得GC
初始标记（停顿）-并发标记-二次标记（停顿）-并发删除


>Serial(串行GC)收集器：单线程，复制算法，效率较高
>ParNew(并行GC)收集器：serial收集器的多线程版本
>Parallel Scavenge(并行回收GC)收集器：复制算法，并行多线程，目标是高吞吐量，吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)
>Serial Old(串行GC)收集器：Serial收集器的老年代版本，单线程，标记整理算法
>Parallel Old(并行GC)收集器：Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。
>CMS(并发GC)收集器：以获取最短回收停顿时间为目标的收集器，标记清除算法，初始标记，并发标记，重新标记，并发清除。初始标记、重新标记这两个步骤任然需要停顿其他用户线程。初始标记仅仅只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。优点：并发收集，低停顿。缺点：CPU敏感，吞吐量低，无法处理浮动垃圾，会有碎片
>G1收集器：标记整理，无碎片

- **Minor GC与Full GC分别在什么时候发生**

Minor GC：年轻代内存回收，每次 Minor GC 会清理年轻代的内存。分配内存时Eden不够开始启动。
Major GC ：清理永久代。许多 Major GC 是由 Minor GC 触发的
Full GC ：清理整个堆空间—包括年轻代和永久代。

- **几种常用的内存调试工具：jmap、jstack、jconsole**

jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。

- **类加载的五个过程：加载、验证、准备、解析、初始化**

- **双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader**

某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

委托机制的意义 — 防止内存中出现多份同样的字节码 

我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。
![enter image description here](http://img.blog.csdn.net/20140828211837525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenE2MDIzMTY0OTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

- **分派：静态分派与动态分派**

静态分派：所有依赖静态类型来定位方法执行版本的分派动作，都称为静态分派，静态分派的最典型应用就是多态性中的方法重载。静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的。

动态分派：动态分派与多态性的另一个重要体现——方法覆写有着很紧密的关系。向上转型后调用子类覆写的方法便是一个很好地说明动态分派的例子。

单分派和多分派：方法的接受者（亦即方法的调用者）与方法的参数统称为方法的宗量。单分派是根据一个宗量对目标方法进行选择，多分派是根据多于一个宗量对目标方法进行选择。
![enter image description here](http://wiki.jikexueyuan.com/project/java-vm/images/child.png)

###J2SE基础
- **九种基本数据类型的大小，以及他们的封装类**

int、short、float、double、long、boolean、byte、char
Integer、Short、Float、Double、Long、Boolean、Byte、Character

- **Switch能否用string做参数**

switch后面可以跟int，short，char，byte，string

- **equals与==的区别**

基本数据类型，==比较的是值，复合数据类型，==比较的是地址
在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了

- **Object有哪些公用方法**

getClass（），toString（），finalize（），clone（只有实现了Cloneable接口才可以调用该方法），equals（一般equals和==是不一样的，但是在Object中两者是一样的，子类一般都要重写这个方法），hashCode（），wait（wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁），notify（唤醒在该对象上等待的某个线程），notifyAll（唤醒在该对象上等待的所有线程）

- **new和clone创建对象的区别**

>new操作符的本意是分配内存。程序执行到new操作符时， 首先去看new操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。
>clone在第一步是和new相似的， 都是分配内存，调用clone方法时，分配的内存和源对象（即调用clone方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域， 填充完成之后，clone方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部

深拷贝和浅拷贝：（clone执行的是浅拷贝）
![enter image description here](http://img.blog.csdn.net/20140116224712140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmdqZ19ibG9n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

可以自己实现深拷贝，重写clone方法。如果想要深拷贝一个对象， 这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把该对象引用的其他对象也要clone一份 ， 这就要求这个被引用的对象必须也要实现Cloneable接口并且实现clone方法。彻底的深拷贝几乎是无法实现的。

- **Java的四种引用，强弱软虚，用到的场景**

强引用：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存，通常用于cache。

弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。通常用于Debug、内存监视工具等程序中。

虚引用：顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

- **Hashcode的作用**

hashcode方法返回该对象的哈希码值，主要用于查找的快捷性

如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致

所有的object都有hashcode方法，根据物理地址生成hash值

String的hashcode和equals被重写，都是比较内容

hashcode针对地址，equals针对值，若hashcode相同，equals不一定相同，若equals相同，则hashcode一定相同，所以先判断hashcode在判断equals效率比较高

- **ArrayList、LinkedList、Vector的区别**

ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构

对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针
对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据

Vector也是采用数组方式存储，但使用了synchronized同步方法，是线程安全的，但是效率比较低

ArrayList扩展时0.5倍+1，Vector扩展时1倍

Collection：都有clone方法，是序列化类
List：ArrayList，Vector(Stack),LinkedList
Set：HashSet(LinkedHashSet),SortedSet(TreeSet)
Map：HashTable(Properties),HashMap(LinkedHashMap),SortedMap(TreeMap)

- **String、StringBuffer与StringBuilder的区别**

都是final类，不能被继承

>string  字符串常量
>stringbuffer  线程安全的字符串变量
>stringbuilder  非线程安全的字符串变量

- **Map、Set、List、Queue、Stack的特点与用法**

Stack：先进后出。add(),contains(),isEmpty(),get(),size(),toArray(),peek(),pop(),push(),remove()
Set：无重复。add(),contains(),isEmpty(),size(),remove(),toArray()
Queue：先进先出。add(),offer(),peek(),poll(),remove
List：可以重复，是一个列表。
Map：键值对，键没有重复。containsKey(),containsValue(),get(),put(),remove()

- **HashMap和HashTable的区别**

HashTable：synchronized，键和值都不能是null，线程安全的

HashMap：非线程安全，允许一个键为null和多个值为null，迭代器是Iterator，是fail-fast的

- **HashMap和ConcurrentHashMap的区别，HashMap的底层源码**

HashMap:线程不安全。用数组和列表实现，拉链发，链表的数组，put时是从前插入链表，随着map的增大，Entry会以一定的规则增加长度，get时null key总是存放在Entry[]的第一个位置，Hash时取模运算%，也可用h&(length-1)。

Hashmap有两个影响因子，初始容量和加载因子，默认加载因子是0.75，当条目数超过初始容量*加载因子时，发生rehash操作，桶的数量增加一倍

HashTable：效率低下

ConcurrentHashMap：使用锁分段效率，提高并发效率，分段存储，分段配锁，操作过程中先定位SegMent，再进入HashEntry（两次hash过程）。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据，一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁

- **TreeMap、HashMap、LindedHashMap的区别**

TreeMap：有序的
HashMap：无序的，遍历速度和map大小有关。1.8优化（若一个桶节点数量过多，链表+数组的结构转换为红黑树）
LinkedHashMap： 记录插入顺序，遍历速度只和实际数据有关

>HashSet是通过HashMap实现的,TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key
>Map的key和Set都有一个共同的特性就是集合的唯一性.TreeMap更是多了一个排序的功能.
>hashCode和equal()是HashMap用的, 因为无需排序所以只需要关注定位和唯一性即可.
     >>hashCode是用来计算hash值的,hash值是用来确定hash表索引的.
     hash表中的一个索引处存放的是一张链表, 所以还要通过equal方法循环比较链上的每一个对象才可以真正定位到键值对应的Entry.
     put时,如果hash表中没定位到,就在链表前加一个Entry,如果定位到了,则更换Entry中的value,并返回旧value
     
>由于TreeMap需要排序,所以需要一个Comparator为键值进行大小比较.当然也是用Comparator定位的.
   >>Comparator可以在创建TreeMap时指定
   如果创建时没有确定,那么就会使用key.compareTo()方法,这就要求key必须实现Comparable接口.
   TreeMap是使用Tree数据结构实现的,所以使用compare接口就可以完成定位了.

- **Collection包结构，与Collections的区别**

Collection是集合类的上级接口，子接口主要有Set 和List、Map。 
Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

- **try catch finally，try里有return，finally还执行么**

若finally里也有return语句则覆盖try或catch中的return语句直接返回
finally块的语句在try或catch中的return语句执行之后返回之前执行
finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值（看是返回值（不影响）还是引用（会影响））

- **Excption与Error包结构，SOF你遇到过哪些情况**

Throwable是 Java 语言中所有错误或异常的超类。
和RuntimeException一样， 编译器也不会检查Error。
Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。

OOM:  out of  memory java heap 溢出  虚拟机扩展栈时没有足够空间  运行常量池溢出，方法区溢出
SOF:  stack overflow memory  请求栈深度大于最大深度

- **OOM**

常见原因：内存中加载的数据量过于庞大，如一次从数据库取出过多数据；集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；代码中存在死循环或循环产生过多重复的对象实体；使用的第三方软件中的BUG；启动参数内存值设定的过小

解决方法：增加JVM大小，优化程序，释放垃圾

- **Java内存泄漏与调试**

内存泄漏：当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放(Remove,移除)他们。

内存泄漏的几大原因：静态集合类，监听器，物理连接，内部类和外部模块等的引用。

为了解决这些问题，我们可以通过软件工具来检查内存泄露，检查的主要原理就是暴露出所有堆中的对象，并且检查这些对象的生存周期，让程序员寻找那些无用但仍被引用的对象。

调试工具：java visualVM

- **Java面向对象的三个特征与含义**

>java面向对象的三个特征与含义：封装，继承，多态
所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。
所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。
多态的三个条件：继承，重写，向上转型   基于继承实现多态，基于接口实现多态
编译时的多态,是指参数列表的不同, 来区分不同的函数, 在编译后, 就自动变成两个不同的函数名. 在运行时谈不上多态
运行时多态:用到的是后期绑定的技术, 在程序运行前不知道,会调用那个方法, 而到运行时, 通过运算程序,动态的算出被调用的地址. 动态调用在继承的时候,方法名 参数列表完全相同时才出现运行时多态!
运行时多态,也就是动态绑定,是指在执行期间(而非编译期间)判断所引用对象的实际类型,根据实际类型判断并调用相应的属性和方法.

- **Override（重写）Overload（重载）的含义去区别**

>如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。 
如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载(Overloading)。不能通过访问权限、返回类型、抛出的异常进行重载.

- **Interface与abstract类的区别**

抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。

对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。

抽象层次不同：抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
跨域不同：抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在"is-a" 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。
设计层次不同：抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

- **Static class 与non static class的区别**

静态类只能是内部类

>1. 静态内部类可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法。 
>2. 静态内部类只能够访问外部类的静态成员,而非静态内部类则可以访问外部类的所有成员(方法，属性)。 
>3. 实例化一个非静态的内部类的方法得先实例化一个外部类，而静态内部类则不需要，可以通过类名直接调用。
>4. 静态内部类可以单独初始化，静态内部类使用场景一般是当外部类需要使用内部类，而内部类无需外部类资源，并且内部类可以单独创建的时候会考虑采用静态内部类的设计。
   


- **java多态的实现原理**

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

对于面向对象而已，多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。

Java实现多态有三个必要条件：继承、重写、向上转型。基于继承实现多态，基于接口实现多态。

当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。

- **java多线程，实现多线程的两种方法：Thread与Runable**

![enter image description here](http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg)

每一个Java线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java线程的优先级是一个整数，其取值范围是1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级NORM_PRIORITY（5）。

 通过实现Runnable接口创建线程
  > 定义一个类实现Runnable接口，重写接口中的run()方法。在run()方法中加入具体的任务代码或处理逻辑
  > 创建Runnable接口实现类的对象
  > 创建一个Thread类的对象，需要封装前面Runnable接口实现类的对象
  > 调用Thread对象的start()方法，启动线程 new Thread(tt).start();
  
 通过继承Thread类创建线程
  > 首先定义一个类去继承Thread父类，重写父类中的run()方法。在run()方法中加入具体的任务代码或处理逻辑
  > 直接创建一个ThreadDemo2类的对象，也可以利用多态性，变量声明为父类的类型
  > 调用start方法，线程t启动，隐含的调用run()方法，new ThreadDemo2().start();  

- **线程同步的方法：sychronized、lock、reentrantLock等**

1. sychronized：用来修饰方法与同步块，一个对象可以有多个synchronized，但只有一个对象锁，就好比一个大房子，大门打开，有很多屋子，有的屋子锁了，有的屋子没锁，但只有一把钥匙，同步代码块可以指定其他大房子的钥匙。
2. 使用特殊域变量(Volatile)实现线程同步。volatile关键字为域变量的访问提供了一种免锁机制；使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新；因此每次使用该域就要重新计算，而不是使用寄存器中的值；volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。
3. volatile是java并发的最轻量级实现，在生成的汇编语言中加入lock关键字和内存屏障，只保证读取和写入是内存安全的，但是无法实现自增线程安全，用来修饰成员变量，放入共享内存。
4. 使用重入锁实现同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。
5. 使用局部变量实现线程同步。

- **锁的种类**

线程的阻塞和唤醒需要cpu从用户态转换为核心态，负担很重

无锁状态

偏向锁状态：释放不做任何事情，Markvalue会保留状态，省去了CAS操作，在不同线程申请时升级为轻量级锁

轻量级锁状态：首先去获取锁，失败升级为自旋锁（执行无意义的循环，循环结束重新竞争锁，省去了阻塞锁的时间空间开销），仍然失败膨胀为重量级锁

重量级锁状态：为一个对象监视器，包含一个竞争锁的队列（互斥），一个信号阻塞队列（线程同步）

- **ThreadLocal的设计理念与作用**

Java中的ThreadLocal类允许我们创建只能被同一个线程读写的变量。因此，如果一段代码含有一个ThreadLocal变量的引用，即使两个线程同时执行这段代码，它们也无法访问到对方的ThreadLocal变量。
创建：
``` java
private ThreadLocal myThreadLocal = new ThreadLocal();
```
由于在ThreadLocal对象中设置的值只能被设置这个值的线程访问到，线程无法在ThreadLocal对象上使用set()方法保存一个初始值，并且这个初始值能被所有线程访问到。但是我们可以通过创建一个ThreadLocal的子类并且重写initialValue()方法，来为一个ThreadLocal对象指定一个初始值。

- **ThreadPool用法与优势**

优势：降低资源消耗，提高响应速度，提高线程的可管理性

线程池的使用：
>线程池的创建:
``` java
new  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```
>提交任务：execute（无返回值）；submit （有返回值）
>线程池的关闭：shutdown（只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程）；shutdownNow（首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表）

线程池的使用流程：
![enter image description here](http://cdn3.infoqstatic.com/statics_s1_20160726-0420u1/resource/articles/java-threadPool/zh/resources/threadpool.jpg)

- **Concurrent包**

三种并发粒度
>• JVM 级别更改。大多数现代处理器对并发对某一硬件级别提供支持，通常以 compare-and-swap （CAS）指令形式。CAS 是一种低级别的、细粒度的技术，它允许多个线程更新一个内存位置，同时能够检测其他线程的冲突并进行恢复。它是许多高性能并发算法的基础。在 JDK 5.0 之前，Java 语言中用于协调线程之间的访问的惟一原语是同步，同步是更重量级和粗粒度的。公开 CAS 可以开发高度可伸缩的并发 Java 类。这些更改主要由 JDK 库类使用，而不是由开发人员使用。
• 低级实用程序类 -- 锁定和原子类。使用 CAS 作为并发原语，ReentrantLock 类提供与 synchronized 原语相同的锁定和内存语义，然而这样可以更好地控制锁定（如计时的锁定等待、锁定轮询和可中断的锁定等待）和提供更好的可伸缩性（竞争时的高性能）。大多数开发人员将不再直接使用 ReentrantLock 类，而是使用在 ReentrantLock 类上构建的高级类。
• 高级实用程序类。这些类实现并发构建块，每个计算机科学文本中都会讲述这些类 -- 信号、互斥、闩锁、屏障、交换程序、线程池和线程安全集合类等。大部分开发人员都可以在应用程序中用这些类，来替换许多（如果不是全部）同步、wait() 和 notify() 的使用，从而提高性能、可读性和正确性。

java.util.concurrent 包添加了多个新的线程安全集合类（ConcurrentHashMap、CopyOnWriteArrayList 和 CopyOnWriteArraySet），这些集合类性能更好。这些类的目的是提供高性能、高度可伸缩性、线程安全的基本集合类型版本。

LinkedList 已经进行了改进来实现 Queue。
PriorityQueue 非线程安全的优先级对列（堆）实现，根据自然顺序或比较器返回元素。
ConcurrentLinkedQueue 快速、线程安全的、无阻塞 FIFO 队列。

使用 Future 构建缓存。使用 Future 描述缓存值，该值可能已经计算，或者可能在其他线程中"正在构造"。确保仅有一个线程试图计算给定关键字的值。如果其他线程随后请求同一关键字的值，它仅能等待（通过 Future.get() 的帮助）第一个线程完成。因此两个线程不会计算相同的值。

Semaphore 类实现标准 Dijkstra 计数信号。计数信号可以认为具有一定数量的许可权，该许可权可以获得或释放。如果有剩余的许可权，acquire() 方法将成功，否则该方法将被阻塞，直到有可用的许可权（通过其他线程释放许可权）。线程一次可以获得多个许可权。计数信号可以用于限制有权对资源进行并发访问的线程数。该方法对于实现资源池或限制 Web 爬虫（Web crawler）中的输出 socket 连接非常有用。注意信号不跟踪哪个线程拥有多少许可权；这由应用程序来决定，以确保何时线程释放许可权，该信号表示其他线程拥有许可权或者正在释放许可权，以及其他线程知道它的许可权已释放。

互斥。计数信号的一种特殊情况是互斥，或者互斥信号。互斥就是具有单一许可权的计数信号，意味着在给定时间仅一个线程可以具有许可权（也称为二进制信号）。互斥可以用于管理对共享资源的独占访问。虽然互斥许多地方与锁定一样，但互斥还有一个锁定通常没有的其他功能，就是互斥可以由具有许可权的线程之外的其他线程来释放。这在死锁恢复时会非常有用。

CyclicBarrier 类可以帮助同步，它允许一组线程等待整个线程组到达公共屏障点。CyclicBarrier 是使用整型变量构造的，其确定组中的线程数。当一个线程到达屏障时（通过调用 CyclicBarrier.await()），它会被阻塞，直到所有线程都到达屏障，然后在该点允许所有线程继续执行。该操作与许多家庭逛商业街相似 -- 每个家庭成员都自己走，并商定 1:00 在电影院集合。当您到电影院但不是所有人都到了时，您会坐下来等其他人到达。然后所有人一起离开。认为屏障是循环的是因为它可以重新使用；一旦所有线程都已经在屏障处集合并释放，则可以将该屏障重新初始化到它的初始状态。 还可以指定在屏障处等待时的超时；如果在该时间内其余线程还没有到达屏障，则认为屏障被打破，所有正在等待的线程会收到 BrokenBarrierException。

CountdownLatch 类与 CyclicBarrier 相似，因为它的角色是对已经在它们中间分摊了问题的一组线程进行协调。它也是使用整型变量构造的，指明计数的初始值，但是与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。其中，CyclicBarrier 是到达屏障的所有线程的大门，只有当所有线程都已经到达屏障或屏障被打破时，才允许这些线程通过，CountdownLatch 将到达和等待功能分离。任何线程都可以通过调用 countDown() 减少当前计数，这种不会阻塞线程，而只是减少计数。await() 方法的行为与 CyclicBarrier.await() 稍微有所不同，调用 await() 任何线程都会被阻塞，直到闩锁计数减少为零，在该点等待的所有线程才被释放，对 await() 的后续调用将立即返回。当问题已经分解为许多部分，每个线程都被分配一部分计算时，CountdownLatch 非常有用。在工作线程结束时，它们将减少计数，协调线程可以在闩锁处等待当前这一批计算结束，然后继续移至下一批计算。

Java 语言内置了锁定工具 -- synchronized 关键字。当线程获得监视器时（内置锁定），其他线程如果试图获得相同锁定，那么它们将被阻塞，直到第一个线程释放该锁定。同步还确保随后获得相同锁定的线程可以看到之前的线程在具有该锁定时所修改的变量的值，从而确保如果类正确地同步了共享状态的访问权，那么线程将不会看到变量的"失效"值，这是缓存或编译器优化的结果。

ReentrantLock 是具有与隐式监视器锁定（使用 synchronized 方法和语句访问）相同的基本行为和语义的 Lock 的实现，但它具有扩展的能力。作为额外收获，在竞争条件下，ReentrantLock 的实现要比现在的 synchronized 实现更具有可伸缩性。（有可能在 JVM 的将来版本中改进 synchronized 的竞争性能。）这意味着当许多线程都竞争相同锁定时，使用 ReentrantLock 的吞吐量通常要比 synchronized 好。换句话说，当许多线程试图访问 ReentrantLock 保护的共享资源时，JVM 将花费较少的时间来调度线程，而用更多个时间执行线程。虽然 ReentrantLock 类有许多优点，但是与同步相比，它有一个主要缺点 -- 它可能忘记释放锁定。

ReentrantLock 实现的锁定规则非常简单 -- 每当一个线程具有锁定时，其他线程必须等待，直到该锁定可用。有时，当对数据结构的读取通常多于修改时，可以使用更复杂的称为读写锁定的锁定结构，它允许有多个并发读者，同时还允许一个写入者独占锁定。该方法在一般情况下（只读）提供了更大的并发性，同时在必要时仍提供独占访问的安全性。ReadWriteLock 接口和 ReentrantReadWriteLock 类提供这种功能 -- 多读者、单写入者锁定规则，可以用这种功能来保护共享的易变资源。

- **wait()和sleep()的区别**

>sleep():
>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。
>sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。
>在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 
>wait():
>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问。
>wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。
>wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。

- **foreach与正常for循环效率对比**

for比foreach在大数据量上效率高，for如果使用不规范容易越界，foreach内部迭代器使用+循环

- **Java IO与NIO**

NIO的抽象数据类型：buffer，channel，selector

NIO和IO的区别：
>IO—->面向流、阻塞IO
>NIO—>面向缓冲、非阻塞IO、选择器

Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。

Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。

- **list，map删除元素**

不能使用foreach循环，会越界；不能使用for循环，删除后会漏掉，最好使用.next（）

```java
for (Map.Entry<Integer, Integer> entry : map.entrySet()) { 
 
    System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());  

} 
```

- **ConcurrentLinkedQueue**


- **java反射机制，反射的作用与原理**

反射机制就是可以把一个类,类的成员(函数,属性)，当成一个对象来操作

使用反射机制的地方：JDBC-class.forName(Driver)，分析类文件，访问不能访问的变量或属性，工厂模式-Factory类中用反射的话，添加了一个新的类之后，就不需要再修改工厂类Factory了

- **泛型常用特点，List<String>能否转为List<Object>**

泛型：允许在定义类和接口的时候使用类型参数，声明的类型参数在使用时用具体的类型来替换，通常用于集合里面

跟原生类型没有什么区别，只是在接口后面加入了一个尖括号，尖括号里面是一个类型参数（定义时就是一个格式化的类型参数，在调用时会使用一个具体的类型来替换该类型）

一个static方法，无法访问泛型类的类型参数，因为类还没有实例化，所以，若static方法需要使用泛型能力，必须使其成为泛型方法

边界：即对象进入和离开方法的地点，这正是编译器在编译期执行类型检查并插入转型代码的地点。泛型中的所有动作都发生在边界处：对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。

- **解析XML的几种方式的原理与特点：DOM、SAX、JDOM、DOM4J**

DOM：是基于树或基于对象的。
>优点：允许应用程序对数据和结构做出更改；访问是双向的，可以在任何时候在树中上下导航，获取和操作任意部分的数据
>缺点：通常需要加载整个XML文档来构造层次结构，消耗资源大

SAX：
>优点：不需要等待所有数据都被处理，分析就能立即开始；只在读取数据时检查数据，不需要保存在内存中；可以在某个条件得到满足时停止解析，不必解析整个文档；效率和性能较高，能解析大于系统内存的文档。
>缺点：需要应用程序自己负责TAG的处理逻辑（例如维护父/子关系等），文档越复杂程序就越复杂；单向导航，无法定位文档层次，很难同时访问同一文档的不同部分数据，不支持XPath。

JDOM：
>优点：使用具体类而不是接口，简化了DOM的API；大量使用了Java集合类，方便了Java开发人员。
>缺点：没有较好的灵活性；性能较差。

DOM4J：
>优点：大量使用了Java集合类，方便Java开发人员，同时提供一些提高性能的替代方法；支持XPath；有很好的性能。
>缺点：大量使用了接口，API较为复杂。

- **json，xml，protobuf**

json和xml相当：可读性，可扩展性

json优势：编解码更加简单，体积更小，与javascript交互更加方便，速度更快

xml优势：对数据描述性更强

protobuf：不可读的，体积更小适合传输，支持跨平台多语言，消息格式和兼容性很好，序列化与反序列化速度更快

- **Java与C++对比**

Wirte Once，Run Everywhere
简洁有效；面向对象；适合网络编程和分布式计算；解释性语言可移植性强却效率较低

>提供了GC，对内存进行自动管理，程序员无需再程序中进行分配、释放内存，一般来说不用再担心内存分配错误
>不再使用指针，而是采用其他的方法来弥补
>与C++相比，JAVA取消了多重继承这个类特性，使得类的继承变得简洁
>避免了赋值语句和逻辑语句的混淆，同时取消了其他值与布尔值之间的自动转换，这一点有效地降低了某些运行时错误。

- **1.8新特性**

1. 接口中可以实现方法了（接口可以实现static的方法，并且调用的时候是用:接口名.方法名（）；接口可以实现default的方法，调用的时候，必须用该接口的实现类的对象来调用）
2. java8中支持lambda表达式（实际上是匿名内部类；代替匿名内部类，实现事件处理，遍历list集合，对集合中每个元素应用函数）
>(参数1，参数2) ->{
>方法体
>}


- **JNI的使用**

![enter image description here](http://pic002.cnblogs.com/images/2011/269610/2011061500160640.png)

###数据库
####基础知识
- **linux连接数据库**
>连接前 import java.sql.*;
>Class.forName("com.mysql.jdbc.Driver")
- **索引**
>键值+逻辑指针
>聚集索引（稀疏）：表顺序按照索引顺序来存储，叶子节点存储了真实的数据页，不再有单独的数据页
>非聚集索引（密集）：表存储顺序与索引顺序无关，叶节点包含索引字段值及指向数据页数据行的逻辑指针，该层紧邻数据页；叶子节点为每一个真正数据行存储了一个键-指针对，存储了指针和指针偏移量
>索引覆盖：将某一查询中包含的所需字段皆包含于一个索引中（复合索引）
- **数据库锁**
>锁单元越小，并发能力越强，管理锁开销越大
>读是共享锁，写是排他锁，先读后写的操作是更新锁（意图锁），更新锁成功并且改变了数据时更新锁升级为排他锁

- **如何定位效率低的sql**
>慢查询日志，启动后mysql会写一个包含所有执行时间超过x秒的sql语句日志文件
>show processlist 查看当前实时mysql进程状态

- **事务**
>一组sql语句
>特性：原子性，一致性，隔离性，持久性
>提交：commit
>撤销：rollback
>保留点：savepoint 临时占位符，可以回退
>丢失更新，脏读，不可重复读，幻读

- **存储过程**
>用户通过指定存储过程的名字来调用执行
>创建存储过程时就在服务器上进行了编译
>为以后使用而保存的一条或多条sql语句
>封装处理，保持一致性，防止错误，简化变动管理，增强安全性，提高性能

- **范式**
>1NF：无重复的列
>2NF：主键
>3NF：每个非主属性都不以来主键
>BCNF：每个属性都不依赖于R候选键
>4NF：只有一个多值事实

- **触发器**
>在特定的数据库活动发生时自动执行
>creat trigger

- **游标**
>游标是由结果集和结果集中指向特定记录的游标位置组成，面向行
>创建游标：declare
>使用游标：open cursor  fetch
>关闭游标：close custcursor

- **数据库日志**
>数据库日志满了以后只能进行查询操作
>每个数据库至少包含两个日志文件组
>每个日志文件组至少包含两个日志文件成员

- **视图**
>是虚表，可以简化数据查询语句
>多角度，提高安全性，具有逻辑独立性

- **索引**

>改善检索性能，降低插入、修改、删除的耗时
>create index

- **约束**

>管理如何插入或处理数据库数据的规则
>主键：不能重复
>外键：保证引用完整性
>级联删除
>检查约束：保证一列中的数据满足一组指定条件

- **存储结构**
![enter image description here](http://cms.csdnimg.cn/article/201403/25/53312e630a6e0.jpg)
####MySQL

- **基本功能**
>数据查询：select
>数据操纵：insert，update，delete
>数据定义：creat，drop

- **delete drop truncate**
>delete可以数据会滚，会产生日志，比较慢
>truncate立即执行，删除数据保留表结构
>drop直接删除表结构和数据

- **检索：select** 
>去重：select distinct xxx
>检索前几行：SELECT * FROM table LIMIT 5,10  检索第6-15行
>注释： --   #   /*  */

- **排序：order by**
>为最后一条语句
>可以多列排序
>降序排序：order by xxx desc
>如果想降序排序，每列都得有desc

- **过滤：where**
>where xxx=3.49
>=  !=  <  <=  !<  >  >=  !>
>where xxx between 5 and 10
>字符串要加单引号  is null

- **高级过滤**
>and  or  优先处理and
>where xxx in ('xxx', 'xx')
>in可以包含其他select语句，且效率比or高
>where not xxx='xxx'

- **使用通配符过滤：like**
>%：任意次数任意字符，出去null
>_：单个字符
>[]：指定字符集  where xxx like '[xz]%'
>^：否定  where xxx like '[^xz]%'

- **创建计算字段**
> / + - *  执行算术计算
>as：使用别名
>rtrim：去除右边空格 ltrim：去除左边空格  trim：去除两边空格
>字符串连接：+  concat

- **汇总数据**
>avg：select avg（xxx）as sss
>count：count（*）null也计算在内    count（xx）忽略null
>max
>min
>sum
>distinct：select avg（distinct xx）as sss

- **分组数据**
>group by
>having：group by xxx having xx>=2

- **连结**
>内连结：普通的等值连结 where a=b，可以重复；自然连接可以选择列，不能重复
>如果没有where字句，则变成全连结，即笛卡尔乘积
>外连结：left outer join ;right outer join;full outer join

####HBase
- **HBase特性**
1 高可靠性
2 高效性
3 面向列
4 可伸缩
5 可在廉价PC Server搭建大规模结构化存储集群

- **HBase关系图**
![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400463595.jpg)

- **HBase 数据模型**
![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400513336.jpg)
>Row Key：Table主键 行键 Table中记录按照Row Key排序
Timestamp： 每次对数据操作对应的时间戳，也即数据的version number
Column Family：列簇，一个table在水平方向有一个或者多个列簇，列簇可由任意多个Column组成，列簇支持动态扩展，无须预定义数量及类型，二进制存储，用户需自行进行类型转换

- **Table&Region**

![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400532513.jpg)
>Table随着记录增多不断变大，会自动分裂成多份Splits，成为Regions
一个region由[startkey，endkey)表示
不同region会被Master分配给相应的RegionServer进行管理

- ** 两张特殊表：-ROOT- & .META.**

![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400544147.jpg)
>.META. 　　记录用户表的Region信息，同时，.META.也可以有多个region
-ROOT-	　  记录.META.表的Region信息，但是，-ROOT-只有一个region
Zookeeper中记录了-ROOT-表的location
客户端访问数据的流程：
Client -> Zookeeper -> -ROOT- -> .META. -> 用户数据表
多次网络操作，不过client端有cache缓存

- **HBase系统架构**

>Client：
使用HBase RPC机制与HMaster和HRegionServer进行通信
Client与HMaster进行通信进行管理类操作
Client与HRegionServer进行数据读写类操作

>Zookeeper：
Zookeeper Quorum存储-ROOT-表地址、HMaster地址
HRegionServer把自己以Ephedral方式注册到Zookeeper中，HMaster随时感知各个HRegionServer的健康状况
Zookeeper避免HMaster单点问题

>HMaster：
HMaster没有单点问题，HBase中可以启动多个HMaster，通过Zookeeper的Master Election机制保证总有一个Master在运行
主要负责Table和Region的管理工作：
1 管理用户对表的增删改查操作
2 管理HRegionServer的负载均衡，调整Region分布
3 Region Split后，负责新Region的分布
4 在HRegionServer停机后，负责失效HRegionServer上Region迁移
![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400561367.jpg)

>HRegionServer：
HBase中最核心的模块，主要负责响应用户I/O请求，向HDFS文件系统中读写数据
HRegionServer管理一些列HRegion对象；
每个HRegion对应Table中一个Region，HRegion由多个HStore组成；
每个HStore对应Table中一个Column Family的存储；
Column Family就是一个集中的存储单元，故将具有相同IO特性的Column放在一个Column Family会更高效
![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400572691.jpg)

>HStore：
HBase存储的核心。由MemStore和StoreFile组成。
MemStore是Sorted Memory Buffer。
Client写入 -> 存入MemStore，一直到MemStore满 -> Flush成一个StoreFile，直至增长到一定阈值 -> 出发Compact合并操作 -> 多个StoreFile合并成一个StoreFile，同时进行版本合并和数据删除 -> 当StoreFiles Compact后，逐步形成越来越大的StoreFile -> 单个StoreFile大小超过一定阈值后，触发Split操作，把当前Region Split成2个Region，Region会下线，新Split出的2个孩子Region会被HMaster分配到相应的HRegionServer上，使得原先1个Region的压力得以分流到2个Region上。由此过程可知，HBase只是增加数据，有所得更新和删除操作，都是在Compact阶段做的，所以，用户写操作只需要进入到内存即可立即返回，从而保证I/O高性能。
![enter image description here](http://pic002.cnblogs.com/images/2012/79891/2012060400574793.gif)

http://www.cnblogs.com/shitouer/archive/2012/06/04/2533518.html

###设计模式
http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html
####简单工厂模式
>考虑一个简单的软件应用场景，一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观，如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。

>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。
简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。
简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。
####工厂方法模式
>现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。

>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。
工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。
工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。
工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。
####抽象工厂模式
>在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。
为了更清晰地理解工厂方法模式，需要先引入两个概念：
产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。
抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。
抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。
抽象工厂模式包含四个角色：抽象工厂用于声明生成抽象产品的方法；具体工厂实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。
抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。
抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。
抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
####建造者模式
>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。
在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。
复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。

>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。
建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造
在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。
建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。
建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。
####单例模式
>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。
如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。
一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。

>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。
单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。
单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。
单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。
单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。

``` java
public class Singleton {
    private volatile static Singleton instance; //声明成 volatile
    private Singleton (){}
    public static Singleton getSingleton() {
        if (instance == null) {                         
            synchronized (Singleton.class) {
                if (instance == null) {       
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
####适配器模式
>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。
通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。
在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。
在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。
适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。

>结构型模式描述如何将类或者对象结合在一起形成更大的结构。
适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。
在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。
适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。
适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。
####装饰模式
>一般有两种方式可以实现给一个类或对象增加行为：
继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。
关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)
装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。

>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功 能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模 式。
装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）； 抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具 体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。
使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动 态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子 类的情况下，将对象的功能加以扩展。
装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的 方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的 排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可 以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺 点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承 更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需 要逐级排查，较为烦琐。
装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给 单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地 被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。
装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客 户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构 件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允 许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。
####外观模式
>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。

>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。
外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。
外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。
外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。
####命令模式
>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。
命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。
命令模式包含四个角色：抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。
命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。
命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。
####观察者模式
>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。

>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。
观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。
观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。
MVC是观察者模式的经典应用。
在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。
####策略模式
>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。
在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。
在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。
除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。
为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。
策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。
策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。
策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。
策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。

###常用工具
####Linux
####Git
>git init 初始化
>git status  需要commit的新文件
>git diff  还没有提交的不同

>git clone  copy项目到本地
>git checkout  下载分支

>git add   添加文件
>git commit 添加到本地仓库
>git push 添加到远程仓库

>git branch 创建分支
>git merge 合并分支
![enter image description here](http://image.beekka.com/blog/2014/bg2014061202.jpg)
####Vim
>h j k l 左 下 上右
>gg 第一行 5G 第五行 G 最后一行
>i 编辑模式 Esc 退出编辑
>:wq 保存并推出 :q! 不保存强制退出
>yy 复制当前行 dd剪切当前行 p 在光标后粘贴 P 在光标前粘贴
####Maven
>mvn clean 删除
>mvn compile
>mvn test
>mvn package
>mvn install
>pom.xml  repository   dependencies
####Markdown
>   # 标题
>   _ _ 斜体 * * 加粗
>   块 >
>   list * space
>   插入图片 ![]()
>   代码  六个` 或者段首四个空格
###机器学习
###MapReduce&Storm
####MapReduce
####Storm

##LeetCode相关知识点
#面试部分
##技术面试
- **高并发，高负载技术**
>DNS负载均衡器分流技术
>减小网页大小，增加带宽
>减少前端链接数
>前段页面静态化，并放在内存/缓存中
>优化查询，查询结果缓存，使用反向代理
>缓存：更新方式，过时失效，后端通知（复杂，但实时性高），换页算法，重建与持久化
>
>使用冗余数据，避免表连接操作
>镜像数据，可以负载均衡，有一致性问题
>数据拆分：按照逻辑拆分；平均按照id分；竖着按照字段分
>负载均衡，任务分配系统，需要任务队列和持久化，及时替用和失效备援等高可用性技术，中央分配式，下游请缨式
>异步处理：收集请求，延时处理，用队列，需要线程通信，回滚复杂，并发控制，消息机制
>限流阀：使用队列限流
>批量处理技术：把基本相同的技术批量处理


- **如何设计高并发系统**
>做负载均衡
>使用分布式系统和分布式数据库
>使用缓存，减少I/O
>优化数据库
- **海量数据处理方法**
>1.bloom过滤器，实现数据字典，可以查找是否存在
>2.hashing，快速查找、删除，d-left hashing，查找一个key时，进行d次hash，同时查找d个位置，做了一个负载均衡化的处理
>3.bit-map，快速查找，判重，删除，nbit-map，n个bit-map
>4.堆：求n个最大值，n个最小值；双堆，一个最大堆一个最小堆，可以用来维护中位数
>5.双层桶划分，快速查找，寻找中位数，定位中位数在一个桶中
>6.数据库索引，大数据的增删改查
>7.倒排索引，正向索引-文档指向包含它的单词，反向索引-单词指向包含它的文档
>8.外排序，大数据的排序，外排序采用归并原理，置换选择败者树原理
>9.trie树，数据量多，重复多，数据种类小，查query，去重，寻找热门搜索
>10.mapreduce

- **bloom过滤器**
>m bit array，k个hash function
>add，用k个hash function映射到k个bit，置为1
>query，查看是否k个bit全为1
>不允许remove
>当元素增多，失败率增加，需要重组filter，有一定的失误率

##HR面试
1. XXX（某个比较重要的点）是怎么实现的？

2. 你在项目中遇到的最大的困难是什么，怎么解决的？

3. 项目某个部分考虑的不够全面，如果XXXX，你怎么优化？

4. XXX（一个新功能）需要实现，你有什么思路？

5. 贵公司一向以XXX著称，能不能说明一下公司这方面的特点？

2. 贵公司XXX业务发展很好，这是公司发展的重点么？

3. 对技术和业务怎么看？

4. 贵公司一般的团队是多大，几个人负责一个产品或者业务？

5. 贵公司的开发中是否会使用到一些最新技术？

6. 对新人有没有什么培训，会不会安排导师？

7. 对Full Stack怎么看？

8. 你觉得我有哪些需要提高的地方？

9. 你觉得XX公司怎么样，为什么选择XX公司？

10. 技术路线有什么打算

11. 在项目中学到了什么，遇到了什么困难，怎么解决的？

1. 我的优缺点
2. 高兴的事和伤心的事
3. 职业规划
4. 理想
#项目部分
##微信实习
- **具体拓扑结构**
- **朋友圈是怎么实现的**
- **搭建数据中心框架**
- **学习storm Trident**
- **学习paxos**
- **学习kafka connector**


##FW实习
##百度实习
##岛礁防护系统项目
##Adaboost人脸检测项目
#简历部分

